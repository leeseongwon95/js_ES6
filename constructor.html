<div></div>
<button id="버튼">버튼</button>

<script>
    document.getElementById('버튼').addEventListener('click',
    function(e){
        console.log(this);  
        console.log(e.currentTarget); // 지금 이벤트 동작하는 곳 // 4 this : e.currentTarget

        var Array = [1,2,3]; // forEach 반복문
        Array.forEach(function(a){ // 이건 콜백함수 : 그냥 함수 안에 들어가는 함수를 콜백함수라고 부름
            console.log(a); // 내부코드가 3번 반복됨
                    // a : 어레이 안에 있던 하나하나의 데이터들 
            console.log(this); // 여기서 this 를 출력하면 ? 함수가 쓰인 위치에 따라 this 값이 변함

        })
    })


    var 오브젝트1 = {
        이름들 : ['김', '이', '박'],
        함수 : function(){
            console.log(this); // 위 함수를 소유한 오브젝트1 을 출력함
            오브젝트1.이름들.forEach(function(){ // 근본없는 일반함수 
                console.log(this); // this 값이 window ? 
            })
        }
    }
    
    오브젝트1.함수();

    var 오브젝트2 = {
        이름들 : ['김', '이', '박'],
        함수 : function(){
            console.log(this); // 위 함수를 소유한 오브젝트1 을 출력함
            오브젝트1.이름들.forEach(() => { // arrow function 특징 :  내부의 this 값을 변화시키지 않음 (외부 this 값 그대로 재사용가능)
                console.log(this); // 상위에 있는 this 값을 그대로 물려받아서 사용함
            })
        }
    }

    // bind(this), call(this) 같은 것처럼 this 조작할때 arrow function 으로 조작 가능

    var anything = {}

    function 기계() { // 오브젝트 생성기계 (constructor)
        this.이름 = "Kim";
        // 새로 생성되는 오브젝트 (instance)
        // this 3 : 기계 안에서 쓰면 새로 생성되는 오브젝트를 뜻함
    }

    var 오브젝트 = new 기계();

</script>